/*jslint
    fudge, node
*/

import {
    constant,
    identity,
    compose
} from "@jlrwi/combinators";
import {
    type_check
} from "@jlrwi/esfunctions";

const type_name = "Requestor";

const create = function (unary_fx) {
    return function requestor(callback) {
        return function (value) {
            try {
                callback(unary_fx(value));
            } catch (exception) {
                callback(undefined, exception.message);
            }
        };
    };
};

// Semigroupoid :: <b -> c> -> <a -> b> -> <a -> c>
const adt_compose = function (bc_requestor) {
    return function (ab_requestor) {
        return function composed_requestor(final_callback) {
            return function (a) {
                let cancel_function;
                let cancel_reason;

// return to caller to invoke cancel fx for the current requestor
                const cancel = function (reason) {
// if we have a cancel function, invoke it
                    if (type_check("function")(cancel_function)) {
                        return cancel_function(reason);
                    }

// signal that user requested cancel during requestor lacking a cancel fx
                    cancel_reason = (
                        (reason === undefined)
                        ? "Composed requestor cancelled by user"
                        : reason
                    );
                };

                const ab_callback = function (b, reason) {
// If ab_requestor fails, abort
                    if (b === undefined) {
                        final_callback(undefined, reason);

// if cancel was requested during first requestor that didn't have a cancel fx,
// don't continue to second requestor
                    } else if (cancel_reason !== undefined) {
                        final_callback(undefined, cancel_reason);

// Start the next requestor and update the cancel function
                    } else {
                        cancel_function = bc_requestor(final_callback)(b);
                    }
                };

// Store ab_requestor's cancel function
                cancel_function = ab_requestor(ab_callback)(a);
                return cancel;
            };
        };
    };
};

// Category :: <a -> a>
const id = create(identity);

// Functor :: (a -> b) -> <c -> a> -> <c -> b>
const map = compose(adt_compose)(create);

// Note that (b -> c) is NOT a requestor
// Apply :: <a -> (b -> c)> -> <a -> b> -> <a -> c>
const ap = function (abc_requestor) {
    return function (ab_requestor) {
        return function ap_requestor(final_callback) {
            return function (a) {
                let cancel_function;
                let cancel_reason;

// Try to cancel whichever requestor is active at the moment
                const cancel = function (reason) {

// If there's a cancel_function, invoke it
                    if (type_check("function")(cancel_function)) {
                        return cancel_function(reason);
                    }

// No cancel function for current requestor - save message for later
                    cancel_reason = (
                        type_check("string")(reason)
                        ? reason
                        : "Apply requestor cancelled by user"
                    );
                };

// abc's callback will trigger ab next with (b -> c)
                const abc_callback = function (fbc, reason) {
// abc_requestor failed -> abort
                    if (fbc === undefined) {
                        final_callback(undefined, reason);

// User attempted to cancel but requestor didn't stop, so abort now
                    } else if (cancel_reason !== undefined) {
                        final_callback(undefined, cancel_reason);

// Invoke ab_requestor and store cancel fx
                    } else {
                        cancel_function = map(
                            fbc
                        )(
                            ab_requestor
                        )(
                            final_callback
                        )(
                            a
                        );
                    }
                };

// Invoke abc_requestor and store any cancel function
                cancel_function = abc_requestor(abc_callback)(a);
                return cancel;
            };
        };
    };
};

// Applicative :: b -> <a->b>
const of = compose(create)(constant);

// (b -> <a -> c>) is NOT a requestor, but returns a requestor
// Chain :: (b -> <a -> c>) -> <a -> b> -> <a -> c>
const chain = function (fbac) {
    return function (ab_requestor) {
        return function chain_requestor(final_callback) {
            return function (a) {
                let cancel_function;
                let cancel_reason;

// Try to cancel whichever requestor is active at the moment
                const cancel = function (reason) {

// If there's a cancel_function, invoke it
                    if (type_check("function")(cancel_function)) {
                        return cancel_function(reason);
                    }

// No cancel function for current requestor - save message for later
                    cancel_reason = (
                        type_check("string")(reason)
                        ? reason
                        : "Chained requestor cancelled by user"
                    );
                };

                const ab_callback = function (ac_requestor, reason) {
// ab_requestor failed - abort
                    if (ac_requestor === undefined) {
                        final_callback(undefined, reason);

// User attempted to cancel but requestor didn't stop
                    } else if (cancel_reason !== undefined) {
                        final_callback(undefined, cancel_reason);

// Finally invoke the <a->c> requestor with a
                    } else {
                        cancel_function = ac_requestor(final_callback)(a);
                    }
                };

// Extract the <a->c> requestor
                cancel_function = adt_compose(
                    create(fbac)
                )(
                    ab_requestor
                )(
                    ab_callback
                )(
                    a
                );
                return cancel;
            };
        };
    };
};

// Extend :: (<a -> b> -> c) -> <a -> b> -> <a -> c>
// fabc takes a requestor <a->b> and returns c
//      *it must call the requestor internally
//      *there is a (b->c) in the internal callback
//      *the result of sending <a->b> to fabc needs to be turned into a req
// !!! fabc applied with a requestor will not necessarily return immediately
//const extend = compose(create)(fabc);

// Contravariant :: (b -> a) -> <a -> c> -> <b -> c>
const contramap = function (fba) {
    return function (ac_requestor) {
        return adt_compose(ac_requestor)(create(fba));
    };
};

// Profunctor :: (a -> b) -> (c -> d) -> <b -> c> -> <a -> d>
const promap = function (fab) {
    return function (fcd) {
        return function (bc_requestor) {
            return map(fcd)(contramap(fab)(bc_requestor));
        };
    };
};

const validate = function (requestor) {
    const dummy_callback = function (ignore) {
        return;
    };

// Check if requestor is a function
    if (type_check("function")(requestor)) {
        return false;
    }

// See if the result of supplying a callback to requestor is also a function
    try {
        return type_check("function")(requestor(dummy_callback));
    } catch (ignore) {
        return false;
    }
};

const type_factory = function (ignore) {
    return Object.freeze({
        spec: "StaticLand",
        version: 1,
        type_name,
        ap,
        chain,
        compose: adt_compose,
        id,
        map,
        promap,
        of,
        contramap,
        create,
        validate
    });
};

/*

*/

export default Object.freeze(type_factory);
