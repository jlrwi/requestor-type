/*jslint
    fudge
*/

import {
    constant,
    identity,
    compose
} from "@jlrwi/combinators";
import {
    type_check
} from "@jlrwi/esfunctions";


const type_name = "Requestor";

//A requestor represents a future result (or failure) of a generic piece of work
//Requestors are called as follows:
//  requestor (callback) (parameter)
//where callback takes the form:
//  callback (value, reason) {}
//and requestor can return a cancel function of the form:
//  cancel (reason)

//create <a -> b>
const create = function (unary_fx) {
    return function requestor (callback) {
        return function (value) {
            try {
                return callback (unary_fx (value));
            } catch (err) {
                return callback (undefined, err);
            }
        };
    };
};


// Functor :: (a -> b) -> F<c->a> -> F<c->b>
const map = function (f) {
    return function (requestor) {

        // Return a new requestor by applying a callback to original
        return function (callback) {

            const mapped_callback = function (value, reason) {
                return (
                    value === undefined
                    ? callback (undefined, reason)
                    : callback (f (value))
                );
            };

            return requestor (mapped_callback);
        };
    };
};

// Apply :: <a -> (b -> c)> -> <a -> b> -> <a -> c>
const ap = function (abc_requestor) {
    return function (ab_requestor) {
        return function (final_callback) {
            return function (a) {
                // Use result of abc_requestor (b->c) to build callback for ab
                const build_ab_callback = function (fbc) {
                    return function (b, reason) {
                        if (b === undefined) {
                            final_callback (undefined, reason);
                        } else {
                            // Create a requestor from fbc and invoke it with b
                            create (fbc) (final_callback) (b);
                        }
                    };
                };

                // abc's callback will trigger ab next with (b -> c)
                const abc_callback = function (fbc, reason) {
                    if (fbc === undefined) {
                        final_callback (undefined, reason);
                    } else {
                        // value is (b -> c)
                        ab_requestor (build_ab_callback (fbc)) (a);
                    }
                };

                abc_requestor (abc_callback) (a);
            };
        };
    };
};

// Applicative :: b -> <a->b>
const of = compose (create) (constant);

// Chain :: (b -> <a -> c>) -> <a -> b> -> <a -> c>
const chain = function (fbac) {
    return function (ab_requestor) {
        return function (final_callback) {
            return function (a) {

                const ac_callback = function (c, reason) {
                    if (c === undefined) {
                        final_callback (undefined, reason);
                    } else {
                        final_callback (c);
                    }
                };

                // ab's callback will trigger ab next with (b -> c)
                const ab_callback = function (b, reason) {
                    if (b === undefined) {
                        final_callback (undefined, reason);
                    } else {
                        // fbac produces an <a->c> requestor
                        fbac (b) (ac_callback) (a);
                    }
                };

                ab_requestor (ab_callback) (a);
            };
        };
    };
};

// Profunctor :: (a -> b) -> (c -> d) -> <b -> c> -> <a -> d>
const promap = function (fab) {
    return function (fcd) {
        return function (bc_requestor) {
            return map (fcd) (contramap (fab) (bc_requestor));
        };
    };
};

// Contravariant :: (b -> a) -> <a -> c> -> <b -> c>
const contramap = function (f) {
    return function (ac_requestor) {
        return function (callback) {
            return compose (ac_requestor (callback)) (f);
        };
    };
};

// Extend :: (<a -> b> -> c) -> <a -> b> -> <a -> c>
// fabc takes a requestor <a->b> and returns c
//      *it must call the requestor internally
//      *there is a (b->c) in the internal callback
//      *the result of sending <a->b> to fabc needs to be turned into a req
// !!! fabc applied with a requestor will not necessarily return immediately
//const extend = compose (create) (fabc);

const adt_compose = function (bc_requestor) {
    return function (ab_requestor) {
        return function (final_callback) {
            const ab_callback = function (b, reason) {
                if (b === undefined) {
                    final_callback (undefined, reason);
                } else {
                    bc_requestor (final_callback) (b);
                }
            };
            return ab_requestor (ab_callback);
        };
    };
};

const id = create (identity);

const validate = function (requestor) {
    const dummy_callback = function (ignore) {
        return;
    };

    if (type_check ("function") (requestor)) {
        try {
            return type_check ("function") (requestor (dummy_callback));
        } catch (ignore) {
            return false;
        }
    }

    return false;
};

const type_factory = function (ignore) {
    return Object.freeze({
        spec: "StaticLand",
        version: 1,
        type_name,
        ap,
        chain,
        compose: adt_compose,
        id,
        map,
        promap,
        of,
        contramap,
        create,
        validate
    });
};



/*
*/















export default Object.freeze(type_factory);
